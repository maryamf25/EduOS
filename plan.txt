Creating a Custom OS for Your Semester Project

Building a custom operating system is an ambitious but manageable project for one month. Here's a step-by-step guide to create something unique yet achievable.

Project Idea: "EduOS" - A Minimal Educational Operating System

Create a small OS that demonstrates core OS concepts while providing an educational interface.

Phase 1: Foundation (Week 1)

1.1 Setup Development Environment

bash

# Install cross-compiler toolssudo apt-get install build-essential nasm grub-pc-bin xorriso

1.2 Create Basic Bootloader

nasm

; boot.asm - Simple bootloadersection .text

    global _start_start:

    mov si, hello_msg

    call print_string

    jmp $print_string:

    mov ah, 0x0E.loop:

    lodsb

    cmp al, 0

    je .done

    int 0x10

    jmp .loop.done:

    ret



hello_msg db 'EduOS Booting...', 0



times 510-($-$$) db 0

dw 0xAA55

1.3 Kernel Entry Point

c

// kernel.cvoid main() {

    char* video_memory = (char*)0xb8000;

    *video_memory = 'E';

    *(video_memory + 1) = 0x07; // Attribute byte

    // Continue boot process...}

Phase 2: Core Features (Week 2-3)

2.1 Unique Feature: Interactive System Monitor

c

// system_monitor.cvoid display_system_info() {

    clear_screen();

    print_string("=== EduOS System Monitor ===\n");

    print_string("1. Process List\n");

    print_string("2. Memory Usage\n");

    print_string("3. CPU Information\n");

    print_string("4. Educational Modules\n");}void educational_modules() {

    print_string("\n--- OS Concepts Explained ---\n");

    print_string("A. Process Scheduling\n");

    print_string("B. Memory Management\n");

    print_string("C. File Systems\n");

    print_string("D. System Calls\n");}

2.2 Simple Shell Implementation

c

// shell.cvoid shell() {

    char input[100];

    while(1) {

        print_string("EduOS> ");

        read_string(input);

        

        if(strcmp(input, "monitor") == 0) {

            display_system_info();

        } else if(strcmp(input, "learn") == 0) {

            educational_modules();

        } else if(strcmp(input, "clear") == 0) {

            clear_screen();

        } else {

            print_string("Command not found\n");

        }

    }}

2.3 Process Management (Simplified)

c

// process.ctypedef struct {

    int pid;

    char name[20];

    int state; // 0=ready, 1=running, 2=blocked} Process;



Process processes[10];int process_count = 0;int create_process(char* name) {

    processes[process_count].pid = process_count;

    strcpy(processes[process_count].name, name);

    processes[process_count].state = 0;

    return process_count++;}

Phase 3: Advanced Features (Week 3-4)

3.1 Unique: Visual Memory Map

c

// memory.cvoid display_memory_map() {

    print_string("\nMemory Layout:\n");

    print_string("[0x000000-0x000FFF] - Bootloader\n");

    print_string("[0x001000-0x001FFF] - Kernel\n");

    print_string("[0x002000-0x00FFFF] - Available\n");

    // Visual representation

    print_string("\n▌Boot▐▌Kernel▐▌Free Memory▐\n");}

3.2 File System (Minimal)

c

// filesystem.ctypedef struct {

    char name[8];

    char extension[3];

    int size;

    char data[1024];} File;



File files[50];int file_count = 0;void create_file(char* name, char* data) {

    strcpy(files[file_count].name, name);

    files[file_count].size = strlen(data);

    strcpy(files[file_count].data, data);

    file_count++;}

Building and Testing

Makefile

makefile

# Makefile

C_SOURCES = $(wildcard kernel/*.c drivers/*.c)

OBJ = ${C_SOURCES:.c=.o}all: os-imageos-image: boot/boot.bin kernel.bin

	cat $^ > os-imagekernel.bin: kernel/kernel_entry.o ${OBJ}

	ld -o $@ -Ttext 0x1000 $^ --oformat binary%.o: %.c

	gcc -ffreestanding -c $< -o $@%.o: %.asm

	nasm $< -f elf -o $@%.bin: %.asm

	nasm $< -f bin -o $@clean:

	rm -rf *.bin *.o os-image

Testing with QEMU

bash

qemu-system-i386 -fda os-image

Unique Features to Implement

Interactive OS Concepts Demonstrator

Visual process scheduling simulation

Memory allocation animations

File system structure visualization

Built-in Educational Content

Short explanations of OS concepts

Interactive examples

"How it works" demonstrations

System Visualization

Real-time memory usage graphs

Process state diagrams

I/O operation animations

Project Structure

text

EduOS/

├── boot/

│   ├── boot.asm

│   └── kernel_entry.asm

├── kernel/

│   ├── kernel.c

│   ├── shell.c

│   ├── process.c

│   ├── memory.c

│   └── filesystem.c

├── drivers/

│   ├── screen.c

│   └── keyboard.c

└── Makefile

Timeline

Week 1: Bootloader, basic kernel, text output

Week 2: Shell, basic commands, process management

Week 3: Memory management, file system, educational content

Week 4: Integration, testing, documentation, demo preparation

What Makes It Amazing Yet Achievable

Demonstrates Core Concepts: Shows how real OSes work

Interactive: Users can learn while using

Visual Feedback: Makes abstract concepts tangible

Extensible: Can be expanded after the course

Impressive Demo: Visual elements make for great presentations

This project balances complexity with educational value, giving you a solid foundation in OS development while creating something unique and demonstratable within one month.

